MODULE ProductionRun

    USE Config
    USE Format
    USE Library
    USE ClusterRoutines,  ONLY : collapsed, dspecies, evaluate, getEnergy, getGnorm, dataMineCluster, &
                                 evaluate_single_x, notValidCluster
    USE Environment,      ONLY : findRestartData, getRestartData, reportItemDone
    USE File,             ONLY : logEnergy, logMessage, printBestSet, removeArcFiles, removeClusterFiles, &
                                 readCAR, peek, outputXYZ
    USE Master,           ONLY : checkHashkey, MASTER_CLUSTER, updateBestSet
    USE RdfRoutines,      ONLY : computeOcc
    USE Utilities,        ONLY : getHashKey, getHashkeyRadius, updateDataMiningMasterCluster
    USE Moveclass,        ONLY : crossover
    USE Population,       ONLY : sortPopulation, removeDuplicatesX
    USE GeneticAlgorithm, ONLY : gaGenerateStatistics
    USE Timer

    IMPLICIT NONE

!   Ideally would like these routines to allow any structures within restart 
!   to be converted to input files for single point or refinement calculations
!
!   Currently atoms (number and species type) must match that in Master file

CONTAINS

  !==========================================================================================!
  ! Generates statistics for the production run
  !==========================================================================================!
  SUBROUTINE prodGenerateStatistics(in_pop)
    TYPE(cluster), INTENT(IN), DIMENSION(:) :: in_pop

    INTEGER :: n, i, out_unit=26, out_error=1

    CHARACTER(LEN=1) :: comma = ','
    REAL(KIND=DBL) :: energy

    OPEN(UNIT=out_unit, FILE=TRIM(RELAXED_FOLDER)//'prodStatistics.csv', STATUS='REPLACE', &
      ACTION='WRITE', IOSTAT=out_error, IOMSG=ERROR_MSG)

    n = SIZE(in_pop)

    WRITE(UNIT=out_unit,FMT=*, IOSTAT=out_error, IOMSG=ERROR_MSG) 'ClusterNo,ClusterID,hashkey,edefn,Energy'

    DO i = 1, n

      IF (in_pop(i)%edefn .LE. 0) THEN
        energy = 0.0
      ELSE
        energy = in_pop(i)%energy(in_pop(i)%edefn)
      ENDIF

      WRITE(UNIT=out_unit,FMT='(I5,A1,A5,A1,A27,A1,I5,A1,ES14.7)', IOSTAT=out_error, IOMSG=ERROR_MSG) &
        i, comma, in_pop(i)%id, comma, in_pop(i)%hashkey, comma, in_pop(i)%edefn, comma, energy
    ENDDO

    CLOSE(out_unit)

    RETURN

  END SUBROUTINE prodGenerateStatistics

  !==========================================================================================!
  ! A routine to run crossover for the same parents for many attemps
  !==========================================================================================!
  SUBROUTINE runEnforcedCrossover

    INTEGER :: i, validClusterCnt, duplCnt
    TYPE(cluster) :: parent1, parent2, child
    TYPE(cluster), DIMENSION(1:HGA_POP) :: validChildren
    CHARACTER(LEN=20) :: fileMessage
    CHARACTER(LEN=100) :: message
    CHARACTER(LEN=200) :: fileName
    LOGICAL :: invalidcluster


    ! Reading in the parents
    CALL readCAR(parent1, TRIM(HGA_FILE1))
    CALL readCAR(parent2, TRIM(HGA_FILE2))

    CALL peek(parent1)
    CALL peek(parent2)

    validClusterCnt = 0

    ! Mating
    DO i = 1, HGA_POP

      WRITE(message, *) "Crossover attempt: " // TRIM(ADJUSTL(intToStr(i)))
      CALL printLog("runEnforcedCrossover", message, 10)

      child = crossover(parent1, parent2, .TRUE., HGA_CROSS_ATTEMPTS)

      child%ga_stats%gaOrigin = "CROSSO"
      child%ga_stats%gaGenNo = GA_ITER

      child%id = INITIAL_PREFIX // TRIM(ADJUSTL(intToChar(i)))

      CALL evaluate_single_x(child)

      invalidCluster = notValidCluster(child)

      WRITE(message, *) "Crossover attempt: " // TRIM(ADJUSTL(intToStr(i))) // " Invalid cluster?: ", invalidcluster
      CALL printLog("runEnforcedCrossover", message, 10)

      IF (.NOT. invalidCluster) THEN
        validClusterCnt = validClusterCnt + 1
        validChildren(validClusterCnt) = child

        CALL sortPopulation(validChildren, validClusterCnt)

        duplCnt = removeDuplicatesX(validChildren, validClusterCnt)

        validClusterCnt = validClusterCnt - duplCnt

        IF (MOD(i, 10) == 0) THEN
          WRITE(message, *) "Crossover attempt: " // TRIM(ADJUSTL(intToStr(i))) // " Unique clusters: ", &
            TRIM(ADJUSTL(intToStr(validClusterCnt)))

          CALL printLog("runEnforcedCrossover", message, 5)
        ENDIF
      ENDIF
    ENDDO

    WRITE(message, *) "Finished. Time to count the eggs.."
    CALL printLog("runEnforcedCrossover", message, 5)

    CALL gaGenerateStatistics(validChildren)

    ! Saving valid children in to files
    fileMessage = "Generated by KLMC"
    DO i = 1, validClusterCnt
      fileName = TRIM(validChildren(i)%id)

      fileName = TRIM(BEST_FOLDER) // TRIM(fileName)

      CALL outputXYZ(validChildren(i), fileMessage, fileName)
    ENDDO

  END SUBROUTINE runEnforcedCrossover

  !==========================================================================================!
SUBROUTINE runProduction
    LOGICAL :: reject, pbc
    CHARACTER(LEN=2), DIMENSION(:), ALLOCATABLE :: atom_sym
    TYPE(atom), DIMENSION(:), ALLOCATABLE :: MASTER_SITES
    TYPE(cluster),DIMENSION(1) :: cluster_eval
    TYPE(cluster) :: cluster_temp
    REAL(KIND=DBL), DIMENSION(:), ALLOCATABLE :: region_occ
    REAL(KIND=DBL) :: energy, gnorm
    INTEGER :: n, item_no=0
    LOGICAL :: structFound
    TYPE(cluster), DIMENSION(:), ALLOCATABLE :: productionClusters

    pbc=(index(UNIT_CELL,'cell').ne.0.OR.index(UNIT_CELL,'vector').ne.0)

    ! If data mining, master cluster must be changed accordingly
    IF ((DM_FLAG) .AND. (JOB_TYPE .EQ. 0)) THEN
      CALL updateDataMiningMasterCluster()
    ENDIF

    IF (L_COMPUTE_OCC) THEN
      ALLOCATE(MASTER_SITES(N_ATOMS))
      ALLOCATE(region_occ(0:N_REGIONS))
      DO n=1,N_ATOMS
        MASTER_SITES(n)=MASTER_CLUSTER%atoms(n)
      ENDDO
    ENDIF

    IF (L_ENFORCE_MASTER) THEN
      ALLOCATE(atom_sym(N_ATOMS))
      DO n=1,N_ATOMS
        atom_sym(n)=MASTER_CLUSTER%atoms(n)%symbol
      ENDDO
    ENDIF

    CALL findRestartData() ! define N_SEEDS and find out which structures to process


    ALLOCATE(productionClusters(N_SEEDS))

    nscans: DO item_no = 1, N_SEEDS
      cluster_temp = MASTER_CLUSTER

      structFound = .FALSE.

      cluster_temp%id=INITIAL_PREFIX//TRIM(ADJUSTL(intToChar(item_no)))

      CALL getRestartData(cluster_temp, item_no)
      IF (L_ENFORCE_MASTER) THEN
        DO n=1,N_ATOMS
          cluster_temp%atoms(n)%symbol=atom_sym(n)
        ENDDO
      ENDIF

      cluster_eval(1) = cluster_temp

      ! DAtamining: changing atoms and their positions
      IF ((DM_FLAG) .AND. (JOB_TYPE .EQ. 0)) THEN
        CALL dataMineCluster(cluster_eval(1))
      ENDIF

      IF (L_USE_TOP_ANALYSIS) THEN

        ! This is nasty way to do it, but for now it will do
        IF (hashRadius .EQ. 0.0) THEN
          hashRadius = getHashkeyRadius(cluster_eval(1), N_ATOMS)
        ENDIF

        cluster_eval(1)%hashkey = getHashKey(cluster_eval(1), hashRadius)
        structFound = checkHashkey(cluster_eval(1))

      ENDIF

      IF (.NOT. structFound) THEN
        CALL evaluate(cluster_eval)

        cluster_temp = cluster_eval(1)
        energy = getEnergy(cluster_temp)
        gnorm = getGnorm(cluster_temp)

        reject = .false.

        IF (.NOT. L_NONE_RUN) THEN
          IF (cluster_temp%edefn == 0) THEN ! Reject energy not defined
            CALL logMessage(item_no,R_ENERGY_ZERO,'        Energy not defined!')
            reject=.true.
          ELSEIF (gnorm < -1.5) THEN ! Reject - GULP did not finish 2nd run
            CALL logMessage(item_no,energy,' 2nd Gulp run didnt finish!')
            reject=.true.
          ELSEIF (gnorm < -0.5) THEN ! Reject - GULP did not finish 1st run
            CALL logMessage(item_no,energy,' Gulp did not finish fully!')
            reject=.true.
          ELSEIF (L_GULP_OPTI .AND. collapsed(cluster_temp,R_COLLAPSE, USE_VARIABLE_RAD_COLL)) THEN   ! Cluster has collapsed
            CALL logMessage(item_no,energy,'      Cluster has collapsed!')
            reject=.true.
          ELSEIF (L_GULP_OPTI .AND. dspecies(cluster_temp,R_SPECIES)) THEN ! like-charges too close
            CALL logMessage(item_no,energy,'      Transfer of electrons!')
            reject=.true.
          ENDIF
        ENDIF

        IF (reject) THEN
          energy=R_ENERGY_ZERO
          !CALL removeClusterFiles(cluster_temp)
          IF(pbc)CALL removeArcFiles(cluster_temp)
        ENDIF

        ! Keep a record (hard copy) of the best configurations found
        IF (INT_MAX_BEST > 0 .AND. energy < R_BEST_EMAX) THEN
          CALL updateBestSet(cluster_temp)
        ENDIF
      ENDIF

      IF (L_COMPUTE_OCC) THEN
!       CALL computeOcc(cluster_temp,MASTER_SITES,region_occ)
        CALL printBanner('Occupancies')
        DO n=0,N_REGIONS
          CALL printHeaderCentred('Region '//intToChar(n)//' : '//realToChar(region_occ(n)))
        ENDDO
        CALL printHeaderLine
      ENDIF

      CALL logEnergy(cluster_temp, energy)
      CALL reportItemDone(item_no)

      productionClusters(item_no) = cluster_temp

    ENDDO nscans

    CALL printBanner('Production Run Completed')

    ! Save statistics into a file
    CALL prodGenerateStatistics(productionClusters)

    IF (INT_MAX_BEST > 0) THEN
      CALL printBestSet(0)
    ENDIF

    IF (L_ENFORCE_MASTER) THEN
      DEALLOCATE(atom_sym)
    ENDIF

    IF (L_COMPUTE_OCC) THEN
      DEALLOCATE(MASTER_SITES)
      DEALLOCATE(region_occ)
    ENDIF

    DEALLOCATE(productionClusters)

END SUBROUTINE runProduction

END MODULE ProductionRun
